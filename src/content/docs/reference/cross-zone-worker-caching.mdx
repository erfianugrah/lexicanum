---
title: "Caching with Cloudflare Workers: When to Use What"
description: Which caching mechanism to use when Workers fetch from different origin types, and architectural patterns for multi-Worker systems
author: Erfi Anugrah
---

import { Aside } from "@astrojs/starlight/components";

How caching behaves when a Cloudflare Worker makes `fetch()` requests to origins proxied through Cloudflare (orange-clouded) on different zones.

**Key insight:** The `cf` caching options (`cacheTtl`, `cacheEverything`, `cacheTtlByStatus`) are ignored for all cross-zone orange-clouded origins. Transformation options like `cf.image` still work.

## Why this happens

From [How the Cache works](https://developers.cloudflare.com/workers/reference/how-the-cache-works/#fetch):

> "First, `fetch` checks to see if the URL matches a different zone. If it does, it reads through that zone's cache (or Worker). Otherwise, it reads through its own zone's cache, even if the URL is for a non-Cloudflare site."

This means requests to cross-zone orange-clouded origins are routed to that zone's edge, not your zone's cache.

From [Cache using fetch](https://developers.cloudflare.com/workers/examples/cache-using-fetch/):

> "Workers operating on behalf of different zones cannot affect each other's cache. You can only override cache keys when making requests within your own zone... or requests to hosts that are not on Cloudflare. When making a request to another Cloudflare zone (for example, belonging to a different Cloudflare customer), that zone fully controls how its own content is cached within Cloudflare; you cannot override it."

This is an intentional security boundary - one zone cannot manipulate another zone's cache behavior.

## How caching actually works

Understanding Cloudflare's caching requires knowing three layers that can influence behavior:

1. **Origin response headers** (`Cache-Control`, `Expires`)
2. **Cloudflare zone settings** (Cache Rules, Edge TTL, Browser TTL)
3. **Worker `cf` options** (`cacheTtl`, `cacheEverything`)

### Default behavior (no `cf` options, no Cache Rules)

When a Worker fetches from **same-zone or non-CF origins** without `cf` options, Cloudflare's [default caching](https://developers.cloudflare.com/cache/concepts/default-cache-behavior/) applies:

| Scenario | Cached? | Why |
|----------|---------|-----|
| Static file extension (.js, .css, .png, etc.) | Yes | [Default cacheable extensions](https://developers.cloudflare.com/cache/concepts/default-cache-behavior/#default-cached-file-extensions) |
| HTML, JSON, or other content | **No** | Not in default extension list |
| Non-default type with `Cache-Control: public, max-age=3600` | **No** | Cloudflare caches by extension, not MIME type - need `cf` options |
| Origin returns `Cache-Control: no-store` or `private` | No | Explicitly non-cacheable |
| Response has `Set-Cookie` header | No | Never cached by CDN |

**Key insight:** Setting `Cache-Control` headers on the origin only controls *how long* something is cached, not *whether* it gets cached. For non-default file types, you need `cf` caching options (`cacheEverything`, `cacheTtl`, or `cacheTtlByStatus`) or a Cache Rule.

<Aside type="caution" title="Cross-zone is different">
For cross-zone orange-clouded origins, your `cf` caching options are ignored - the request is routed to the origin zone's edge, bypassing your zone's cache entirely. If the origin has a Worker, responses won't have a `CF-Cache-Status` header at all (Worker-generated responses don't go through the CDN cache).
</Aside>

### With `cf` options (same zone or non-CF origin)

| cf Option | Effect |
|-----------|--------|
| `cacheEverything: true` | Cache regardless of file extension (respects origin's `Cache-Control` for TTL) |
| `cacheTtl: 3600` | Force cache for 1 hour (implicit `cacheEverything`, ignores origin headers) |
| `cacheTtlByStatus: { "200-299": 3600 }` | Force cache with TTL by status code (implicit `cacheEverything`) |

**Note:** `cacheTtl` and `cacheTtlByStatus` implicitly enable `cacheEverything` - they force caching regardless of file extension. The difference is that `cacheEverything` alone respects the origin's `Cache-Control` header for TTL, while `cacheTtl`/`cacheTtlByStatus` override it.

These options **only work** for same-zone or non-Cloudflare origins. For cross-zone orange-clouded origins, they're ignored.

### Cross-zone behavior

When fetching cross-zone orange-clouded origins:

1. The request goes to the **origin zone's edge**, not yours
2. The origin zone's Cache Rules and settings apply
3. Your `cf` options are ignored
4. The origin's `Cache-Control` headers are respected by the origin zone's cache

This means if you want caching, the **origin zone** must configure it via:
- Setting appropriate `Cache-Control` headers
- Configuring Cache Rules on the origin zone
- Using a Worker on the origin zone with `cf` options

## cf options compatibility

| cf Option | Non-CF / Same Zone | Cross-Zone |
|-----------|-------------------|------------|
| `cacheTtl`, `cacheEverything`, `cacheTtlByStatus` | Yes | **No** |
| `image` | Yes | **Yes** |
| `polish`, `minify`, `mirage` | Yes | **No** (uses origin zone) |

## Workarounds

### Cache API

The Cache API stores responses in the calling Worker's zone cache, bypassing cross-zone restrictions entirely.

```typescript
async function fetchWithCache(request: Request, originUrl: string): Promise<Response> {
  const cache = caches.default;
  const cacheKey = new Request(originUrl, { method: 'GET' });
  
  // Check cache first
  let cached = await cache.match(cacheKey);
  
  if (cached) {
    // Handle cache bypass (e.g., browser refresh)
    const cacheControl = request.headers.get('Cache-Control');
    const shouldBypass = cacheControl?.includes('no-cache');
    
    if (shouldBypass) {
      // Cancel the body stream to avoid resource leaks
      if (cached.body) {
        await cached.body.cancel();
      }
      cached = undefined;
    } else {
      return cached;
    }
  }
  
  // Fetch from origin
  const originResp = await fetch(originUrl);
  
  // Don't cache error responses
  if (!originResp.ok) {
    return originResp;
  }
  
  // Prepare response for caching
  const headers = new Headers(originResp.headers);
  headers.delete('Set-Cookie'); // Cache API won't store responses with Set-Cookie
  
  if (!headers.has('Cache-Control')) {
    headers.set('Cache-Control', 'public, max-age=3600');
  }
  
  const response = new Response(originResp.body, {
    status: originResp.status,
    headers,
  });
  
  // Store in cache (non-blocking)
  // Note: cache.put() is best-effort, no need to await
  cache.put(cacheKey, response.clone());
  
  return response;
}
```

### KV for global consistency

Use KV when you need cached data replicated globally (eventual consistency, up to 60s).

```typescript
async function fetchWithKV(originUrl: string, env: Env): Promise<Response> {
  const cacheKey = new URL(originUrl).pathname;
  
  // Check KV first - store body as arrayBuffer, metadata separately
  const { value, metadata } = await env.CACHE_KV.getWithMetadata<{
    contentType: string;
    status: number;
  }>(cacheKey, 'arrayBuffer');
  
  if (value && metadata) {
    return new Response(value, {
      status: metadata.status,
      headers: { 'Content-Type': metadata.contentType },
    });
  }
  
  // Fetch from origin
  const response = await fetch(originUrl);
  
  if (!response.ok) {
    return response;
  }
  
  // Store in KV: body as value, headers as metadata
  const body = await response.arrayBuffer();
  const contentType = response.headers.get('Content-Type') || 'application/octet-stream';
  
  // Non-blocking write
  env.CACHE_KV.put(cacheKey, body, { 
    expirationTtl: 3600,
    metadata: { contentType, status: response.status },
  });
  
  return new Response(body, {
    status: response.status,
    headers: { 'Content-Type': contentType },
  });
}
```

<Aside type="caution" title="Don't mix Cache API and KV">
Choose one caching strategy per data type. Mixing them creates complexity and potential inconsistency.
</Aside>

## Decision tree

When to use which caching approach:

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontFamily': 'arial, sans-serif', 'lineColor': '#64748b' }, 'flowchart': { 'wrappingWidth': 200 }}}%%
flowchart TD
    Start(["`**Need to cache responses?**`"]) --> OriginType

    OriginType{"`**What is the origin type?**`"}
    OriginType -- Non-CF origin --> FetchCF
    OriginType -- Same zone --> FetchCF
    OriginType -- Cross-zone orange-clouded --> CrossZone

    FetchCF["`**fetch with cf options**
    cacheTtl, cacheEverything,
    cacheTtlByStatus all work`"]

    CrossZone{"`**Need global consistency?**`"}
    CrossZone -- No, per-colo OK --> CacheAPI
    CrossZone -- Yes, global --> Writes

    CacheAPI["`**Cache API**
    Fast, free, per data center
    No tiered caching support`"]

    Writes{"`**Concurrent writes?**`"}
    Writes -- No or rare --> KV["`**KV**
    Global replication
    Eventual consistency up to 60s
    Last-write-wins`"]
    Writes -- Yes, need coordination --> DO["`**Durable Objects + KV**
    DO coordinates writes
    KV for read distribution`"]

    classDef decision fill:#fbbf24,stroke:#b45309,color:#1c1917
    classDef cfOptions fill:#4ade80,stroke:#15803d,color:#1c1917
    classDef cacheApi fill:#60a5fa,stroke:#1d4ed8,color:#1c1917
    classDef kvStorage fill:#c084fc,stroke:#7c3aed,color:#1c1917
    classDef doStorage fill:#fb923c,stroke:#ea580c,color:#1c1917
    classDef startEnd fill:#94a3b8,stroke:#475569,color:#1c1917

    class Start startEnd
    class OriginType,CrossZone,Writes decision
    class FetchCF cfOptions
    class CacheAPI cacheApi
    class KV kvStorage
    class DO doStorage
```

| Option | Use when | Latency | Consistency | Notes |
|--------|----------|---------|-------------|-------|
| `fetch()` + `cf` | Non-CF or same zone | ~0ms | Per-colo | [Docs](https://developers.cloudflare.com/workers/examples/cache-using-fetch/) |
| Cache API | Cross-zone, per-colo OK | ~0ms | Per-colo | [No tiered caching](https://developers.cloudflare.com/workers/runtime-apis/cache/) |
| KV | Cross-zone, global | ~0ms cached | Eventual 60s | [Docs](https://developers.cloudflare.com/kv/concepts/how-kv-works/) |

<Aside type="note" title="Coordinating KV writes">
KV uses last-write-wins semantics. Use [Durable Objects](https://developers.cloudflare.com/durable-objects/) to coordinate writes and prevent race conditions.
</Aside>

## Microservices architecture

In multi-Worker systems (router â†’ origin services), there are two caching approaches:

### Centralized caching (router handles all)

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontFamily': 'arial, sans-serif', 'lineColor': '#64748b', 'primaryTextColor': '#1e293b', 'secondaryTextColor': '#1e293b', 'tertiaryTextColor': '#1e293b' }}}%%
flowchart TD
    Client([Client]) --> Router[Router Worker<br/>Handles caching]
    Router <--> Cache[(Cache Layer)]
    Cache -.->|miss| Origins
    subgraph Origins
        OriginA[Origin A]
        OriginB[Origin B]
        OriginC[Origin C]
    end

    classDef client fill:#94a3b8,stroke:#475569,color:#1c1917
    classDef router fill:#60a5fa,stroke:#1d4ed8,color:#1c1917
    classDef cache fill:#c084fc,stroke:#7c3aed,color:#1c1917
    classDef origin fill:#cbd5e1,stroke:#64748b,color:#1c1917

    class Client client
    class Router router
    class Cache cache
    class OriginA,OriginB,OriginC origin
```

**Which caching mechanism to use in the router:**

| Origin Type | Caching Mechanism | Why |
|-------------|-------------------|-----|
| Not proxied (grey-clouded, non-CF) | `fetch()` with `cf` options | Traffic doesn't go through CF proxy |
| Orange-clouded (same zone) | `fetch()` with `cf` options | Same zone, `cf` options work |
| Orange-clouded (cross-zone) | Cache API or KV | `cf` options ignored, must cache explicitly |

| Pros | Cons |
|------|------|
| Single cache management point | Router becomes bottleneck |
| Consistent behavior | Extra hop latency |
| Easier debugging | Tight coupling to origins |
| Centralized circuit breakers | Router must know all origin semantics |

### Distributed caching (origins decide)

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontFamily': 'arial, sans-serif', 'lineColor': '#64748b', 'primaryTextColor': '#1e293b', 'secondaryTextColor': '#1e293b', 'tertiaryTextColor': '#1e293b' }}}%%
flowchart TD
    Client([Client]) --> Router[Router Worker<br/>Routing only]
    Router --> OriginA[Origin A<br/>max-age=3600]
    Router --> OriginB[Origin B<br/>no-store]
    Router --> OriginC[Origin C<br/>max-age=60]
    
    OriginA -.-> CacheA[(Cache)]
    OriginC -.-> CacheC[(Cache)]

    classDef client fill:#94a3b8,stroke:#475569,color:#1c1917
    classDef router fill:#4ade80,stroke:#15803d,color:#1c1917
    classDef origin fill:#60a5fa,stroke:#1d4ed8,color:#1c1917
    classDef cache fill:#c084fc,stroke:#7c3aed,color:#1c1917

    class Client client
    class Router router
    class OriginA,OriginB,OriginC origin
    class CacheA,CacheC cache
```

| Pros | Cons |
|------|------|
| Each service owns its strategy | Inconsistent behavior |
| No single point of failure | Harder to debug system-wide |
| Independent deployments | Complex invalidation |
| Better separation of concerns | Duplicate logic |

### Recommendation

**Prefer distributed caching for cross-zone Worker architectures:**

1. **Router stays stateless** - routing logic only
2. **Origins control their own caching** - using `cf` options or Cache Rules (for non-default types)
3. **If edge caching needed**, router uses Cache API (since `cf` options are ignored anyway)

This works because:
- `cf` caching options are ignored for cross-zone origins anyway
- Origins understand their own caching needs
- Simpler router = fewer failure modes

### Origin-side caching

Origin Workers can cache upstream responses using `cf` options (within the same zone), and signal cacheability to downstream consumers via headers:

```typescript
// Origin Worker - fetches from upstream API and caches at origin's edge
export default {
  async fetch(request: Request): Promise<Response> {
    // Fetch from upstream with cf options (same zone or non-CF = works)
    // cacheTtl implicitly enables cacheEverything (JSON not cached by default)
    const upstream = await fetch('https://api.example.com/data', {
      cf: { cacheTtl: 3600 },
    });
    
    // Worker-generated responses bypass CDN cache
    // Cache-Control tells downstream (router, browser) how long to cache
    return new Response(upstream.body, {
      status: upstream.status,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'public, max-age=3600',
      },
    });
  },
};
```

**Two levels of caching here:**
1. **CDN cache** (via `cf` options) - caches the upstream API response at this zone's edge
2. **Downstream cache** (via `Cache-Control` header) - tells the calling Worker/browser how long to cache this response

For details on how `Cache-Control` headers interact with Cloudflare, see [Origin Cache Control](https://developers.cloudflare.com/cache/concepts/cache-control/).

<Aside type="tip" title="When to centralize">
Use centralized caching when:
- **Origins are third-party APIs** you don't control (can't set Cache Rules or `cf` options on their zone)
- **Origins return `no-store` or `private`** but you know the data is safe to cache
- **You need to aggregate** responses from multiple origins into a single cached response
- **Origins are grey-clouded** or non-Cloudflare and you want edge caching without changing origin config
</Aside>
