---
title: Media Transformation Architecture
description: Multi-mode media transformation (video, frame, spritesheet, audio) on Cloudflare Workers with KV caching and `cdn-cgi/media`
author: Erfi Anugrah
---

import { Aside, Card, CardGrid } from "@astrojs/starlight/components";

How [**video-resizer**](https://github.com/erfianugrah/video-resizer) handles media transformation on Cloudflare Workers.

Single endpoint for video resize, frame extraction, spritesheet generation, and audio extraction. Configuration lives in KV so you don't need to redeploy when changing settings. Two-layer cache (CDN edge + KV) with param validation before hitting the `cdn-cgi/media` endpoint for transformations.

---

## Overview

Four transformation modes:

- **Video**: Resize, compress, adjust quality/playback
- **Frame**: Extract stills at timestamps (jpg/png)
- **Spritesheet**: Grid previews for scrubbing UIs
- **Audio**: Extract m4a audio tracks

Config-driven mode enablement, strong validation, mode-specific strategies. Each mode handles its own param prep and validation (strategy pattern, nothing fancy).

---

## Core Concepts

### Request lifecycle

| Step      | Action                 | Details                                               |
| --------- | ---------------------- | ----------------------------------------------------- |
| 1. Parse  | Normalize query params | Config, derivatives, IMQuery, aliases, mode inference |
| 2. Select | Choose strategy        | Video / Frame / Spritesheet / Audio                   |
| 3. Build  | Create cdn-cgi URL     | Cache version, origins, path resolution               |
| 4. Cache  | Fetch & store          | KV variants + CDN edge caching                        |
| 5. Shape  | Format response        | Headers, filename, range request support              |

### Design patterns

| Pattern               | Purpose                             | Benefit                            |
| --------------------- | ----------------------------------- | ---------------------------------- |
| **Strategy per mode** | Each mode = own validation + params | Add modes without touching handler |
| **Config + schema**   | Zod validation + runtime defaults   | New modes work even if config lags |
| **Translation layer** | Map Akamai/short params to internal | Support multiple param conventions |
| **Cache separation**  | Mode-scoped KV keys                 | No collision between variants      |

### Mode capabilities

| Feature                 | Video       | Frame       | Spritesheet  | Audio      |
| ----------------------- | ----------- | ----------- | ------------ | ---------- |
| **Dimensions**          | ✓ 10–2000px | ✓ 10–2000px | ✓ Required   | ❌         |
| **Fit modes**           | ✓           | ✓           | ✓            | ❌         |
| **Time**                | ✓ 0–10m     | ✓ 0–10m     | ✓ 0–10m      | ✓ 0–10m    |
| **Duration**            | ✓ 1–300s    | ❌          | ✓ 1–300s     | ✓ 1–300s   |
| **Format control**      | ❌          | ✓ jpg/png   | ❌ JPEG only | ✓ m4a only |
| **Quality/compression** | ✓           | ❌          | ❌           | ❌         |
| **Playback params**     | ✓           | ❌          | ❌           | ❌         |

---

## Configuration

### Parameters

| Param      | Values                                         | Range/Rules                                            |
| ---------- | ---------------------------------------------- | ------------------------------------------------------ |
| `mode`     | `video` \| `frame` \| `spritesheet` \| `audio` | Auto-set to `audio` if `format=m4a`                    |
| `format`   | `jpg` \| `png` \| `m4a`                        | Frame: jpg/png, Audio: m4a, Video: ❌, Spritesheet: ❌ |
| `time`     | `0s` – `10m`                                   | Default: `0s` (start position)                         |
| `duration` | `1s` – `300s`                                  | Omit = full length (up to platform limits)             |
| `width`    | `10` – `2000`                                  | Required for spritesheet                               |
| `height`   | `10` – `2000`                                  | Required for spritesheet                               |
| `fit`      | `contain` \| `scale-down` \| `cover`           | Video/Frame/Spritesheet only                           |

:::note[Audio mode restrictions]
Audio disallows: `width`, `height`, `fit`, `quality`, `compression`, playback params
:::

### Cache model

**KV keys:** `mode:path:param1=value1:param2=value2`

```
audio:rocky.mp4:duration=120s:t=30s:f=m4a
video:sample.mp4:w=1280:h=720:q=high
frame:clip.mp4:t=5s:w=640:h=360:f=png
```

**cdn-cgi URL:** Includes all transform params + optional `version` for cache busting

**Headers:** Auto-corrected `Content-Type` per mode, optional `Content-Disposition` filename

---

## Development

### Extending the system

| Task              | Steps                                                                                                                                                                                                 |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Add mode**      | 1. Implement strategy (`prepareTransformParams`, `validateOptions`, `updateDiagnostics`)<br/>2. Add case to `createTransformationStrategy`<br/>3. Add to config defaults/validOptions<br/>4. Document |
| **Add param**     | 1. Add to config validOptions/defaults<br/>2. Handle in option parser<br/>3. Map in param mapping<br/>4. Validate in supporting strategies                                                            |
| **Adjust limits** | Update `timeUtils` validators → Update docs/tests                                                                                                                                                     |

### Operations

```bash
# Upload config
node tools/config-wrapper.js upload \
  --config config/worker-config.json \
  --env production --token <token> --force

# Deploy
npm run deploy:prod  # requires CLOUDFLARE_API_TOKEN

# Debug
?debug=true          # adds diagnostics to response
```

---

## Live examples

:::tip[Test with curl]
Use `--range 0-1023` to check headers without downloading full files
:::

```bash
# Audio (auto mode via format=m4a)
curl -I "https://cdn.erfi.dev/rocky.mp4?format=m4a&filename=audio.m4a"

# Frame thumbnail (PNG, 640x360)
curl -I "https://cdn.erfi.dev/rocky.mp4?mode=frame&time=4s&width=640&height=360&fit=cover&format=png"

# Spritesheet (800x600, 60s window)
curl -I "https://cdn.erfi.dev/rocky.mp4?mode=spritesheet&width=800&height=600&duration=60s"

# Video (resized)
curl -I "https://cdn.erfi.dev/rocky.mp4?width=1280&height=720"
```

### Interactive demos

<CardGrid>
  <Card title="Video" icon="video">
    <video controls width="100%" preload="metadata">
      <source src="https://cdn.erfi.dev/rocky.mp4?width=640&height=360" type="video/mp4" />
    </video>
    <small>640×360 size</small>
  </Card>

<Card title="Frame" icon="picture">
  <img
    alt="Frame at 4s"
    src="https://cdn.erfi.dev/rocky.mp4?mode=frame&time=9s&width=640&height=360&fit=cover&format=png"
    loading="lazy"
    style="width:100%"
  />
  <small>`.png` at 9s timestamp</small>
</Card>

<Card title="Spritesheet" icon="grid">
  <img
    alt="Spritesheet"
    src="https://cdn.erfi.dev/rocky.mp4?mode=spritesheet&width=800&height=600"
    loading="lazy"
    style="width:100%"
  />
  <small>800×600 spritesheet</small>
</Card>

  <Card title="Audio" icon="microphone">
    <audio controls src="https://cdn.erfi.dev/rocky.mp4?mode=audio&time=0s&duration=30s" style="width:100%"></audio>
    <small>`m4a` audio clip</small>
  </Card>
</CardGrid>

---

## Architecture diagrams

### Request flow

How a request flows through the system:

```d2
direction: right

Client -> Handler: ""
Handler -> Strategy: ""
Strategy -> VS: video
Strategy -> FS: frame
Strategy -> SS: spritesheet
Strategy -> AS: audio
VS -> Transform: ""
FS -> Transform: ""
SS -> Transform: ""
AS -> Transform: ""
Transform -> Cache: ""
Cache -> Response: ""

Client: Client
Handler: videoHandler
Strategy: Select Strategy {
  shape: diamond
}
VS: VideoStrategy
FS: FrameStrategy
SS: SpritesheetStrategy
AS: AudioStrategy
Transform: cdn-cgi Transform
Cache: Cache in KV
Response: Response
```

### Strategy pattern for transformation modes

Each mode has its own validation and parameter preparation:

```d2
direction: down

Request -> Parse -> Factory
Factory -> Video: mode=video
Factory -> Frame: mode=frame
Factory -> Sprite: mode=spritesheet
Factory -> Audio: mode=audio

Video -> VParams
Frame -> FParams
Sprite -> SParams
Audio -> AParams

VParams -> CDN
FParams -> CDN
SParams -> CDN
AParams -> CDN

Request: Request with params
Parse: Parse Options
Factory: StrategyFactory
Video: VideoStrategy
Frame: FrameStrategy
Sprite: SpritesheetStrategy
Audio: AudioStrategy
VParams: |md
  Validate & Prepare
  width, height, fit
  quality, compression
  playback params
|
FParams: |md
  Validate & Prepare
  time, format
  width, height, fit
|
SParams: |md
  Validate & Prepare
  width, height required
  time, duration, fit
|
AParams: |md
  Validate & Prepare
  time, duration
  format=m4a only
|
CDN: Build cdn-cgi URL
```

### Caching layers

Two-layer caching with KV and CDN edge:

```d2
direction: right

Request -> KV
KV -> Return1: Hit
KV -> CDN: Miss
CDN -> Return2: Hit
CDN -> Transform: Miss
Transform -> Store -> Return3

Request: Request
KV: KV Cache? {
  shape: diamond
}
Return1: Return Cached
CDN: CDN Cache? {
  shape: diamond
}
Return2: Return Cached
Transform: Transform Media
Store: Store in KV
Return3: Return Response
```

### Origins resolution and fallback

Multi-source storage with automatic fallback:

```d2
direction: right

Request -> Resolve -> Match
Match -> Sources: Yes
Match -> Error404: No

Sources -> R2
R2 -> Success: Found
R2 -> Remote: Not Found
Remote -> Success: Found
Remote -> Fallback: Not Found
Fallback -> Success: Found
Fallback -> Retry: Not Found

Retry -> Exclude: Yes
Retry -> Error404: No
Exclude -> Sources

Request: Request
Resolve: Origin Resolver
Match: Matches Origin? {
  shape: diamond
}
Sources: Try Sources in Priority
Error404: 404 Not Found
R2: R2 Bucket? {
  shape: diamond
}
Success: Return Content
Remote: Remote URL? {
  shape: diamond
}
Fallback: Fallback URL? {
  shape: diamond
}
Retry: From cdn-cgi? {
  shape: diamond
}
Exclude: Exclude Failed Source
```

### R2 source URL resolution (`__r2src`)

`cdn-cgi/media` needs a valid HTTP URL as the source video — it sends HEAD/GET probes to fetch the content for transformation. R2 bucket bindings aren't HTTP-addressable, so R2 sources use a self-referencing URL pattern with a `__r2src` query parameter.

**The problem:** R2 bindings produce `r2:path` references, not HTTP URLs. Passing these to `cdn-cgi/media` results in 9402 errors because cdn-cgi can't resolve them.

**The solution:** When building the source URL for an R2 origin, the worker generates `https://cdn.erfi.dev/{path}?__r2src={bucketBinding}`. When cdn-cgi sends its HEAD/GET probe back to this URL, the worker intercepts requests with `__r2src` early in `index.ts` and serves raw R2 content directly via the bucket binding — bypassing the transformation pipeline entirely.

If an R2 source has a `publicUrl` configured (e.g. a custom domain like `videos.erfi.dev`), that URL is used directly instead, avoiding the self-referencing pattern.

```d2
direction: right

Client -> Worker: /videos/rocky.mp4?width=640
Worker -> CdnCgi: /cdn-cgi/media/width=640/https://cdn.erfi.dev/rocky.mp4?__r2src=VIDEOS_BUCKET
CdnCgi -> Worker2: HEAD rocky.mp4?__r2src=VIDEOS_BUCKET
Worker2 -> R2: r2Bucket.head("rocky.mp4")
R2 -> Worker2: metadata
Worker2 -> CdnCgi: 200 OK + headers
CdnCgi -> Worker3: GET rocky.mp4?__r2src=VIDEOS_BUCKET
Worker3 -> R2b: r2Bucket.get("rocky.mp4")
R2b -> Worker3: stream
Worker3 -> CdnCgi: 200 OK + body
CdnCgi -> Client: transformed video

Client: Client
Worker: Worker (build cdn-cgi URL)
CdnCgi: cdn-cgi/media
Worker2: Worker (__r2src intercept)
Worker3: Worker (__r2src intercept)
R2: R2 Bucket
R2b: R2 Bucket
```

### Cache versioning and cdn-cgi cache busting

`cdn-cgi/media` has its own internal cache that can't be purged directly. Cache versioning solves this by appending a `v=N` query parameter to the source URL inside the cdn-cgi path.

When you purge KV cache entries, the next request sees a KV miss and increments the version (e.g. `v=1` to `v=2`). This changes the cdn-cgi URL, forcing it to treat the request as new and re-fetch + re-transform the source.

```
# v=1 (cached in cdn-cgi)
/cdn-cgi/media/width=640/https://cdn.erfi.dev/rocky.mp4?__r2src=VIDEOS_BUCKET&v=1

# After KV purge → v=2 (cdn-cgi cache miss, fresh transform)
/cdn-cgi/media/width=640/https://cdn.erfi.dev/rocky.mp4?__r2src=VIDEOS_BUCKET&v=2
```

Versions are stored in the `VIDEO_CACHE_KEY_VERSIONS` KV namespace. Under normal operation, the version stays stable. It only increments when a KV cache miss occurs (i.e. after a purge).

:::note[Reference]
Refer to [Cloudflare docs](https://developers.cloudflare.com/stream/transform-videos/#options) for the latest options supported.
:::
